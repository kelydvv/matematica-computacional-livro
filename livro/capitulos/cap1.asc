== Noções Básicas dos Erros

.Objetivos do capítulo
____________________
Ao final deste capítulo você deverá ser capaz de:

* Determinar com precisão o domínio e a imagem de uma função real;
* Dado o gráfico de uma curva, estabelecer se este pertence a uma função;
* Dada uma função, saber estabelecer se ela é injetora, sobrejetora ou bijetora;
* Realizar operações com funções, isto é, soma, substração, produto, divisão e composição de funções;
* Encontrar a inversa de uma função, se ela existir;
* Relacionar-se cada vez mais com a linguagem e o simbolismo matemático relativo às funções definidas no conjunto dos números reais.
____________________




Em forma geral, a resolução de qualquer problema se inicia pela observação e a compreensão do problema em termos científicos, usando teorias já conhecidas; o qual visa a construção de um modelo matemático que deve representar o mais fielmente possível o problema em estudo. Por este motivo, este procedimento é conhecido como fase de modelagem.

Imprecisões como:

... simplificação do modelo matemático, necessário para a obtenção de um modelo matemático solúvel; 
... erro de truncamento, devido à troca de uma serie infinita por uma finita;
... erro de arredondamento, devido à própria estrutura da maquina; 
... erro na obtençãos dos dados, dados imprecisos obtidos de experimentos ou arredondados na entrada;
... etc. 

podem surguir na fase de modelagem, a menos que algumas medidas sejam consideradas, é isto implica na diminuição da precisão dos resultados obtidos ou na obtenção de resultados incorretos.

Pelo exposto, neste capítulo, focaremos a nossa atenção no estudo dos erros, que possam surguir na resolução de um determinado problema, assim como, os erros que surgem da representação de um número no computador e os erros das operações efetuadas. A seguinte figura esquematiza os passos que se seguem para resolver um problema dado:


image::images/cap1/fases.eps[scaledwidth="80%"]

=== Representação dos números no computador


Poderíamos, sempre, esperar que afirmações como 
[latexmath]
++++
\[2+3=5, \quad 2\times 3=6\quad \mbox{e}\quad \left( \sqrt{2}\right)^2 =2,\]
++++
sejam verdadeiras ou válidas num computador. Não entanto, a aritmética executada por um computador é diferente daquela utilizada na Matemática, isto é, num computador estardar, esperamos resultados exatos para 
[latexmath]
++++
\[2+3=5\quad \mbox{e}\quad 2\times 3=6;\]
porém, não necessáriamente obteremos de forma precisa 
\[\left( \sqrt{2}\right)^2 =2,\]
++++
e isto se explicará conhecendo a aritmética que trabalha com um número finito de algarismos.


Na matemática, existem números que são expressos com uma quantidade infinita de algarismos, por exemplo:
[latexmath]
++++
\[\pi= 3.14159 26535\dots, \quad \sqrt{2}=1.4142135623\dots,\quad 
\frac{1}{3}=0.3333333333\dots,
\]
++++
entretanto, no computador, cada número pode ser representado com apenas um número fixo e finito de algarismos, o que implica que números como latexmath:[$\pi$, $\sqrt{2}$ e $\frac{1}{3}$] não podem ser representados de forma exata, e por este motivo recebem uma representação aproximada a qual deverá ser suficientemente próxima do valor exato e será considerada aceitável na maioria das situações. Embora, muitas vezes, a aritmética usada no computador seja satisfatória, quase sempre surgem problemas devido a esta limitação.

 
Comumente, os computadores trabalham os números reais representando-os no sistema binário, a diferença do sistema decimal que normalmente usamos. De fato, quando introduzimos uma informação numérica no computador, esta é automaticamente transformada em sua representação binária (exata ou aproximada), porém, em muitas situações, dita transformação pode acarretar em erros, devido à limitação da sua representação. A implicação deste fato, é que uma simples operação aritmética entre números representados no computador pode já apresentar erros; para evitar isto devem ser consideradas certas formas de conter as imprecisões decorrentes de fatores tanto internos como de externos.  

 

=== Conversão de números do sistema decimal a  binário, e vice-versa

Dados os números:
[latexmath]
++++
\[
(271.375)_{10}\quad \mbox{e}\quad (11010.000111)_2.
\]
++++
Qual é sua representação binária e decimal, respectivamente? Nesta seção, estudaremos e/ou lembraremos como realizar dita conversão. Começemos estudando e/ou lembrando a conversão dos números inteiros. 

===== Conversão de um número inteiro da base 2 para a base 10

Dados os números inteiros na base binária latexmath:[$(11010)_{2}$ e $(1111111)_{2}$], sabemos que estes podem ser reescritos da seguinte forma:

[latexmath]
++++
\[
\begin{array}{ccl}
(11010)_{2}&=& 1\times 2^4 + 1\times 2^3 +0\times 2^2 + 1\times  2^1 + 0 \times 2^0 ;\\
(111111)_{2}&=& 1\times 2^6+1\times 2^5+1\times 2^4 + 1\times 2^3 +1\times 2^2 + 1\times  2^1 + 1 \times 2^0.
\end{array}
\]
++++
De forma geral, dada uma base latexmath:[$\beta\geq 2$], um número nesta base será representado por: 
[latexmath]
++++
\[
(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{\beta},\quad\mbox{com}\quad 0\leq a_j \leq (\beta-1),\quad j=0,\ldots, i,
\]
porém, ele pode ser reescrito da seguinte forma:
\[
(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{\beta}= a_{i}\times \beta^{i} + a_{i-1} \times \beta^{i-1} + \cdots +a_2 \times \beta^{2}+ a_1 \times \beta^{1} + a_0\times \beta^{0} = \sum\limits_{j=0}^{i} a_{j}\times \beta^{j}.
\]
++++

Note que ao efetuar o somatório latexmath:[$\sum\limits_{j=0}^{i} a_{j}\times \beta^{j}$ o resultado já é um número decimal. Portanto, da representação acima, dada uma base  $\beta\geq 2$, podemos converter qualquer número expresso nesta base para sua representação na base $10$].


.{zwsp}
====
.. latexmath:[$(11010)_{2}= 1\times 2^4 + 1\times 2^3 +0\times 2^2 + 1\times  2^1 + 0 \times 2^0 =(26)_{10}$].
Porém, podemos reescrever 
+
[latexmath]
++++
\[
\begin{array}{ccl}
(26)_{10} &=& 2\times (2\times (2\times (2\times 1+1)+0)+1)+0.
\end{array}
\]
++++

.. latexmath:[$(1111111)_{2}= 1\times 2^6+1\times 2^5+1\times 2^4 + 1\times 2^3 +1\times 2^2 + 1\times  2^1 + 1 \times 2^0 =(127)_{10}$].
Porém,  podemos reescrever 
+
[latexmath]
++++
\[
\begin{array}{ccl}
(127)_{10} &=& 2\times(2\times (2\times (2\times (2\times (2\times 1+1)+1)+1)+1)+1)+1.
\end{array}
\]
++++

====


Nestes exemplos, vemos intuitivamente que podemos obter uma forma para converter um número da base binária para a base decimal. Assim, a teoria estabelece que, dado um número na base  latexmath:[$2$: $(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}$ a sua representação na base $10$, denotada por $b_0$], é obtida da seguinte forma:


[latexmath]
++++
\[
\begin{array}{ccl}
b_{i}&=& a_{i};\\
b_{i-1}&=& 2 \times b_{i}+a_{i-1};\\
b_{i-2}&=& 2 \times b_{i-1}+a_{i-2};\\
     &\vdots& \\
b_{1}&=& 2 \times b_{2}+a_1;\\
b_{0}&=& 2 \times b_{1}+a_{0}.
\end{array}
\]
++++


.{zwsp}
====
Do exemplo anterior, temos que os valores dos latexmath:[$b_i$] são:

..  latexmath:[$\,$]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{4}&=& a_{4} &=&1; &&\\
b_{3}&=& 2 \times b_{4}+a_{3} &=&  2\times 1  +1 &=& 3;\\
b_{2}&=& 2 \times b_{3} +a_2&=&  2\times 3  +0 &=& 6;\\
b_{1}&=& 2 \times b_{2} +a_1&=&  2\times 6  +1 &=& 13;\\
b_{0}&=& 2 \times b_{1}+a_0 &=&  2\times 13 +0 &=& 26.
\end{array}
\]
++++

..  latexmath:[$\,$]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{6}&=& a_{6} &=&1; &&\\
b_{5}&=& 2 \times b_{6}+a_{5} &=&  2\times 1  +1 &=& 3;\\
b_{4}&=& 2 \times b_{5} +a_4&=&  2\times 3  +1 &=& 7;\\
b_{3}&=& 2 \times b_{4}+a_{3} &=&  2\times 7  +1 &=& 15;\\
b_{2}&=& 2 \times b_{3} +a_2&=&  2\times 15  +1 &=& 31;\\
b_{1}&=& 2 \times b_{2} +a_1&=&  2\times 31  +1 &=& 63;\\
b_{0}&=& 2 \times b_{1}+a_0 &=&  2\times  63+1 &=& 127.
\end{array}
\]
++++
====



===== Conversão de um número inteiro da base 10 para a base 2

No seguinte exemplo, vamos converter um número inteiro da base decimal para a base binária.


.{zwsp}
====
Considere o número latexmath:[$b_0= (271)_{10}$ e a sua representação em binário $(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}$], isto é,

[latexmath]
++++
\[
\begin{array}{rcl}
(271)_{10} &=&(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}\\
       &=& a_{i}\times 2^{i} + a_{i-1} \times 2^{i} + \cdots +a_2 \times 2^{2}+ a_1 \times 2^{1} + a_0\times 2^{0}\\
&=& 2 \times \left( a_{i}\times 2^{i-1} + a_{i-1} \times 2^{i-2} + \cdots +a_2 \times 2^{1}+ a_1 \times 2^{0}\right)  + a_0\\
&=& 2 \times 135 + 1.
\end{array}
\]
++++
Logo, latexmath:[$a_0=1$, e representa o resto da divisão de $271$ por $2$. Repetindo o processo para $b_1=135$] temos  

[latexmath]
++++
\[
\begin{array}{rcl}
135    &=& a_{i}\times 2^{i-1} + a_{i-1} \times 2^{i-2} + \cdots a_2 \times 2^{1}+ a_1\\ 
       &=& 2 \times \left( a_{i}\times 2^{i-2} + a_{i-1} \times 2^{i-3} + \cdots a_2 \times 2^{0} \right) + a_1 \\
&=& 2 \times 67 + 1.
\end{array}
\]
++++

Assim, latexmath:[$a_1=1$, e representa o resto da divisão de $b_1=135$ por $2$. Repetindo este processo sucessivamente obtemos os  seguintes $b_i'$s e $a_i'$]s:

[latexmath]
++++
\[
\begin{array}{lclcl}
b_0 =271 &=& 2\times 135 +1 &\Rightarrow& a_0 = 1;\\
b_1 =135 &=& 2\times 67  +1 &\Rightarrow& a_1 = 1;\\
b_2 =67  &=& 2\times 33  +1 &\Rightarrow& a_2 = 1;\\
b_3 =33  &=& 2\times 16  +1 &\Rightarrow& a_3 = 1;\\
b_4 =16  &=& 2\times 8   +0 &\Rightarrow& a_4 = 0;\\
b_5 =8   &=& 2\times 4   +0 &\Rightarrow& a_5 = 0;\\
b_6 =4   &=& 2\times 2   +0 &\Rightarrow& a_6 = 0;\\
b_7 =2   &=& 2\times 1   +0 &\Rightarrow& a_7 = 0;\\
b_8 =1   &=& 2\times 0   +1 &\Rightarrow& a_8 = 1.
\end{array}
\]
Portanto, 
\[
(271)_{10}= (100001111)_{2}.
\]
++++
====

Neste exemplo, vimos intuitivamente que podemos obter uma forma para converter um número da base decimal para a base binária. Assim, a teoria estabelece que, dado um número inteiro latexmath:[$n$ na base decimal, com  $(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}$, como sua representação binária, podemos obter o digito binário $a_k$ para cada $k$, $k=0,1,\dots,i$], usando o seguinte algoritmo:

Algoritmo 1.1::

Passo 0: :::  latexmath:[$k=0$]
+
[latexmath]
++++
\[
n_k=n.
\]
++++

Passo 1: :::  Obtenha latexmath:[$q_k$ e $r_k$] tais que:
+
[latexmath]
++++
\[
n_k=2\times q_k + r_k.
\]
++++
+
Faça latexmath:[$a_k=r_k.$]

Passo 2: :::  Se latexmath:[$q_k = 0$], *PARE*.
+
Caso contrário, faça latexmath:[$n_{k+1}=q_k$].
+
Faça latexmath:[$k=k+1$] e volte para o *Passo 1*.


===== Conversão de um número fracionário da base 10 para a base 2

Abordaremos agora a representação de um número fracionário da base latexmath:[$10$] para a base binária.

.{zwsp} 
====
Consideremos o número latexmath:[$n=0.375$, logo, existem os dígitos binários $d_1,d_2,\ldots,d_i,\ldots$], tais que:
[latexmath]
++++
\[n=0.375=(0.d_1d_2\ldots d_i \ldots)_2.
\]
Então
\[
(0.375)_{10}= (0.d_1d_2\ldots d_i \ldots)_2= d_1 \times 2^{-1} + d_2\times 2^{-2} + \cdots + d_i \times 2^{-i} +\cdots
\]
++++

Ao multiplicar cada termo da expressão acima por latexmath:[$2$] obtemos:
[latexmath]
++++
\[
2\times 0.375 = 0.75= 0+ 0.75= d_1  + d_2\times 2^{-1} + d_3\times 2^{-2} +\cdots + d_i \times 2^{-i+1} +\cdots
\]
++++
Assim, latexmath:[$d_1=0$ representa a parte inteira de $2\times 0.375$] e 
[latexmath]
++++
\[
0.75 = d_2\times 2^{-1} + d_3\times 2^{-2} +\cdots + d_i \times 2^{-i+1} +\cdots
\]
++++
representa a parte fraccionária de latexmath:[$2\times 0.375$]. Repetindo novamente este procedimento para latexmath:[$0.75$]:
[latexmath]
++++
\[
0.75= d_2 \times 2^{-1} + d_3\times 2^{-2} + \cdots + d_i \times 2^{-i+1} +\cdots
\]
++++

Ao multiplicar cada termo da expressão anterior por  latexmath:[$2$] obtemos:
[latexmath]
++++
\[
2\times 0.75 = 1.5= 1+ 0.5= d_2 + d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++

Assim, latexmath:[$d_2=1$ representa a parte inteira de $2\times 0.75$] e 
[latexmath]
++++
\[
0.5 = d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++
representa a parte fraccionária de latexmath:[$2\times 0.75$]. Repetindo novamente o procedimento para o número latexmath:[$0.5$]:
[latexmath]
++++
\[
0.5= d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++

Ao multiplicar cada termo da expressão anterior por latexmath:[$2$] obtemos:

[latexmath]
++++
\[
2\times 0.5 = 1.0= 1+ 0.0= d_3 +d_4\times 2^{-1} +\cdots + d_i \times 2^{-i+3} +\cdots
\]
++++

Assim, latexmath:[$d_3=1$ representa a parte inteira de $2\times 0.5$] e 
[latexmath]
++++
\[
0.0 = +d_4\times 2^{-1} +\cdots + d_i \times 2^{-i+3} +\cdots
\]
++++
representa a parte fraccionária de latexmath:[$2\times 0.5$, e como a parte fracionária é zero, o processo termina. Assim, $d_1=0$, $d_2=0$, $d_3=1$]. Portanto 
[latexmath]
++++
\[
(0.375)_{10}= (0.001)_2.
\]
++++
====

[NOTE]
====
No exemplo acima, temos que latexmath:[$n=0.375$] tem uma representação finita na base binária, porém isto  não necessariamente é verdadeiro na maiora dos casos. De forma geral, dado um número latexmath:[$n\in (0,1)$, embora tenha representação finita no sistema decimal, a sua representação na base $2$] pode ser finita ou infinita. O próximo exemplo, ilustrará este fato.
====
	

De forma geral, consideremos um número latexmath:[$n\in(0,1)$ no sistema decimal e $(0.d_1 d_2 \ldots d_i \ldots)_2$], sua representação no sistema binário. Logo, os dígitos binários latexmath:[$d_1, d_2, \ldots, d_i, \ldots $] são obtidos usando o seguinte algoritmo:

Algoritmo 1.2::

Passo 0:::  latexmath:[$k=1$]
+
[latexmath]
++++
\[
r_1=n.
\]
++++
Passo 1:::  Calcule latexmath:[$2 \times r_k$. Se $2\times r_k \geq 1$, faça $d_k=1$]. +
Caso contrário, faça latexmath:[$d_k=0$]
Passo 2::: Faça latexmath:[ $r_{k+1} = 2\times r_k -d_k$. Se $r_{k+1}=0$], *PARE*. +
Caso contrário, faça latexmath:[$k=k+1$] e volte para o *Passo 1*.
 

[NOTE]
Da nota anterior, o *Algoritmo 1.2* pode ou não parar após um número finito de iterações. 

.{zwsp} 
====
No exemplo anterior, temos que para latexmath:[$n=(0.375)_{10}$, $r_4=0$. Agora consideremos $n=(0.2)_{10}$]. Logo, aplicando o *Algoritmo 1.2* obtemos: 
[latexmath]
++++
\[
\begin{array}{llll}
 k=1:& r_1=0.2;\\
&2\times r_1 = 0.4<1 & \Rightarrow 
\left\{ \begin{array}{lcl}
d_1 & = & 0;\\
r_2 & = & 0.4;
\end{array}
   \right.\\
k=2: & 2\times r_2 = 0.8<1 & \Rightarrow 
\left\{ \begin{array}{lcl}
d_2 & = & 0;\\
r_3 & = & 0.8;
\end{array}
   \right.\\	
k=3: & 2\times r_3 = 1.6 \geq 1& \Rightarrow 
\left\{ \begin{array}{lcl}
d_3 & = & 1;\\
r_4 & = & 0.6;
\end{array}
   \right.\\
k=4: & 2\times r_4 = 1.2 \geq 1& \Rightarrow 
\left\{ \begin{array}{lclcl}
d_4 & = & 1;&&\\
r_5 & = & 0.2 &=& r_1.
\end{array}
   \right.\\
\end{array}
\]
++++

Desde que latexmath:[$r_5=r_1$, os resultados obtidos para $k$ de 1 até 4 serão repetidos. Mais ainda,  $0.2=r_1=r_5=r_9=r_{13}\dots$] e assim por diante.  Portanto
[latexmath]
++++
\[
(0.2)_{10} = (0.001100110011\ldots)_2=(0.\overline{0011})_2.
\]
++++
====
[NOTE]
====
A situação vista no exemplo acima, isto é, dado um número na base decimal com representação finita e com representação infinita na base binária, pode gerar erros, não detectáveis por nós, nos resultados obtidos usando  sistemas computacionais que trabalhem no sistema binário.  De fato, ao trabalhar com latexmath:[$(0.2)_{10}$] no computador, ele trabalhará com uma aproximação de latexmath:[$(0.2)_{10}$], devido a que o computador possui uma quantidade fixa de posições para guardar os dígitos da mantissa de um número, e tal aproximação será usada para realizar os cálculos. Portanto, não podemos aguardar um resultado exato. 

====

===== Conversão de um número fracionário da base 2 para a base 10

Dado um número fracionário na base 2, denotado por latexmath:[$(r)_2$], isto é,
[latexmath]
++++
\[
(r)_2=(0.d_1 d_2 \ldots d_i \ldots)_2
\]
++++
obteremos a sua representação na base decimal. 

O algoritmo que apresentaremos para fazer esta transformação é equivalente ao descrito previamente. Inicialmente definimos latexmath:[$r_1=r$, a em cada iteração $k$, o processo multiplica o número $r_k$ por $(10)_{10} = (1010)_2$ para obter o digito $b_k$] como sendo a parte inteira deste produto convertida para a base decimal. Notemos que estas operações devem ser realizadas no sistema binário.


Algoritmo 1.3::

Passo 0:::  latexmath:[$k=1$]
+
[latexmath]
++++
\[
r_1=r.
\]
++++
Passo 1:::  Calcule latexmath:[$w_k=(1010)_2 \times r_k$]. + 
Seja latexmath:[$z_k$] a parte inteira de latexmath:[$w_k$]. +
Faça latexmath:[$b_k$]  igual à conversão de latexmath:[$z_k$] para a base 10.

Passo 2::: Faça latexmath:[$r_{k+1} = w_k -z_k$. Se $r_{k+1}=0$], *PARE*.

Passo 3::: Faça latexmath:[$k=k+1$] e volte para o *Passo 1*.
   
.{zwsp} 
==== 
Dado o número latexmath:[$(r)_2 = (0.000111)_2$], determinemos a sua representação em base 10. 

Solução::
Desde que, latexmath:[$(r)_2 = (0.000111)_2$], temos:
+
[latexmath]
++++
\[
(0.000111)_2=(0.b_1 b_2 \ldots b_j)_{10}.
\]
Do {\bf Algoritmo 1.3}
\[
\begin{array}{llll}
k=1:&r_1=(0.000111)_2;\\
&w_1= (1010)_2\times r_1 = 1.0001 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_1 & = & 1;\\
r_2 & = & 0.00011\neq 0;
\end{array}
   \right.\\
k=2: & w_2=(1010)_2 \times r_2 = 0.1111 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_2 & = & 0;\\
r_3 & = & 0.1111\neq 0;
\end{array}
   \right.\\	
k=3: & w_3=(1010)_2\times r_3 = 1001.011 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_3 & = & 9;\\
r_4 & = & 0.011\neq 0;
\end{array}
   \right.\\
k=4: & w_4=(1010)_2\times r_4 = 11.11 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_4 & = & 3;\\
r_5 & = & 0.11\neq 0;
\end{array}
   \right.\\
k=5: & w_5= (1010)_2\times r_5 = 111.1 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_5 & = & 7;\\
r_6 & = & 0.1\neq 0;
\end{array}
   \right.\\
k=6: & w_6=(1010)_2\times r_6 = 101 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_6 & = & 5;\\
r_7 & = & 0;
\end{array}
   \right.\\
\end{array}
\]
Portanto,
\[
(0.000111)_2 = (0.109375)_{10}.
\]
++++
====

[NOTE]
====
Um número fracionário numa determinada base, sempre será um número fracionário em qualquer outra base.
====

Assim, a seguinte nota responder à pergunta feita no inicio desta seção, além disso, ilustraremos isto com o próximo exemplo.

[NOTE]
====
Se o número em questão tem uma parte inteira e uma parte fracionária, então a sua conversão, em outra base, será obtida decompondo este na soma da parte inteira com a parte fracionária, logo aplicaremos os algoritmos respectivos a cada parte. 
====

.{zwsp}
====
.. Dado o número latexmath:[$ (271.375)_{10}$], determinemos a sua representação em base 2.
Solução::
Desde que
+
[latexmath]
++++
\[
(271.375)_{10}=(271)_{10}+(0.375)_{10}.
\]
Do {\bf Exemplos 1.3(a)} e {\bf 1.4}, temos que
\[
(271)_{10}=(100001111)_2 \quad \mbox{e} \quad (0.375)_{10}=(0.001)_2,
\]
respectivamente. Portanto
\[
(271.375)_{10}=(100001111)_2 +(0.001)_2=(100001111.001)_2.
\]
++++
.. Dado o número latexmath:[$ (11010.000111)_2$], determinemos a sua representação em base 10. 

Solução::
Desde que
+
[latexmath]
++++
\[
(11010.000111)_2=(11010)_2+(0.000111)_2.
\]
Do {\bf Exemplo 1.1(a)} e o exemplo anterior, temos que
\[
(11010)_2=(26)_10 \quad \mbox{e} \quad (0.000111)_2=(0.109375)_{10},
\]
respectivamente. Portanto
\[
(11010.000111)_2=(26)_10+(0.109375)_{10}=(26.109375)_{10}.
\]
++++


====


=== Sistema de Ponto Flutuante Normalizado

Como mencionado previamente, no computador, apenas um subconjunto dos números reais é representado exatamente,  portanto dado qualquer número real a sua representação aproximada será efetuada por truncamento ou arredondamento. Esta representação é denominada de *ponto flutuante normalizado*.

De forma geral, para representar um número no sistema de ponto flutuante normalizado, em geral, precisamos de uma base latexmath:[$\beta\geq 2$, um número de dígitos significativos $n$ e um exponente ${\rm exp}$].

Definição 1.1:: 

... Dado um número real latexmath:[$nr$]. Diz-se que latexmath:[$nr$] está representado no sistema de ponto flutuante normalizado se for possível representá-lo na forma:
+
[latexmath]
++++
\[
{nr}= \pm (0.d_1 d_2 \ldots d_n)\times \beta^{{\rm exp}}
\]
++++
+
onde: 
+
--
* latexmath:[$\beta \geq 2$] é a base do sistema;

* latexmath:[$n$] é o número de dígitos na mantissa; 
+
[latexmath]
++++
\[0\leq d_i \leq (\beta-1), \quad i=1,\ldots, n,\quad\mbox{com}\quad d_1 \neq 0;
\]
++++

* latexmath:[${\rm exp}$ é o expoente no intervalo $[{\rm exp}_{{\rm min}}, {\rm exp}_{{\rm max}}\]$, com ${\rm exp}_{{\rm min}} \leq 0$ e ${\rm exp}_{{\rm max}} \geq 1$] inteiros.
--

... Desde que latexmath:[$d_1 \neq 0$], o zero é representado da seguinte forma:
+
[latexmath]
++++
\[
\mbox{\bf zero}= 0.\underbrace{000000\ldots 0}_{n\,\,\mbox{vezes}} \times \beta^{\exp_{\rm min}} 
\]
++++

... A união de todos os números em ponto flutuante, juntamente com o *zero*, define o *sistema de ponto flutuante normalizado*, que será denotado por latexmath:[${\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$].

[NOTE]
====
Dado o  latexmath:[${\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$] temos que:


.. O menor número positivo exatamente representável, denotado por latexmath:[${\rm m}$],  é dado por:
+
[latexmath]
++++
\[
{\rm m}= 0.1\underbrace{000000\ldots 0}_{(n-1)\,\,\mbox{vezes}} \times \beta^{\exp_{\rm min}};
\]
++++
.. O maior número positivo exatamente representável, denotado por latexmath:[${\rm M}$], é dado por:
+
[latexmath]
++++
\[
{\rm M}= 0 \times \underbrace{[\beta-1][\beta-1]\ldots [\beta-1]}_{n\,\,\mbox{vezes}} \times \beta^{\exp_{\rm max}} 
;\]
++++
.. O número máximo de mantissas positivas possíveis, denotado por latexmath:[${\rm mantissas_{possíveis}}$], é dado por:
+
[latexmath]
++++
\[
{\rm mantissas}_{\rm possíveis}= (\beta-1) \times \beta^{n-1} ;
\]
++++
.. O número máximo de expoentes possíveis, denotado por latexmath:[$\exp_{\rm possíveis}$], é dado por:
+
[latexmath]
++++
\[
\exp_{\rm possíveis}= \exp_{\rm max} - \exp_{\rm min} +1;
\]
++++
..  O número de elementos positivos representáveis, denotado por latexmath:[${\rm NumR}_{+}$], é dado por:
+
[latexmath]
++++
\[
{\rm NumR}_{+}=\mbox{mantissas}_{\rm possiveis} \times \exp_{\rm possiveis};
\]
++++

.. Dado um número real latexmath:[${ nr}\in {\rm SPF}$, temos que  $-{ nr}\in {\rm SPF}$, assim o número total de elementos representáveis, denotado por ${\rm NumR}_{\rm T}$], junto à representação do *zero*, é dado por:
+
[latexmath]
++++
\[
{\rm NumR}_{\rm T} = 2\times {\rm NumR}_{+}+1.
\]
++++

====

O seguinte exemplo ilustra os conceitos da nota acima.

.{zwsp}
====
Se consideramos o sistema de ponto flutuante latexmath:[${\rm SPF}(\beta,n,\exp_{\rm min}, \exp_{\rm max}) ={\rm SPF}(10,3,-5,5)$]. Logo, os números serão representados da seguinte forma:
[latexmath]
++++
\[
0.d_1 d_2 d_3 \times 10^{\exp}, \quad 0\leq d_i \leq 9, \quad d_1\neq 0, \quad \exp \in [-5,5].
\]
++++
Portanto,

.. latexmath:[${\rm m}=0.100 \times 10^{-5}= 10^{-6}$];
.. latexmath:[${\rm M}=0.999 \times 10^{5}= 99900$];
.. latexmath:[${\rm mantissas}_{\rm possiveis}=(10-1)\times 10^{3-1}= 900$];
.. latexmath:[$\exp_{\rm possíveis}=5-(-5)+1=11$];
.. latexmath:[${\rm NumR}_{+}=900\times 11=9900$];
.. latexmath:[${\rm NumR}_{\rm T}=2\times 9900 + 1 = 19801$].

====

Agora, consideremos o conjunto dos números reais, denotado por latexmath:[$\mathbb{R}$, ${\rm SPF}(10,3,-5,5)$], e o conjunto 
[latexmath]
++++
\[
A:=\left\{ x\in \mathbb{R}\,:\,{\rm m}\leq |x| \leq {\rm M}  \right\}.
\]
++++
Logo, dado latexmath:[$x\in \mathbb{R}$] temos as seguintes possibilidades:

... Se latexmath:[$x\in A$, por exemplo $x=135.87= 0.13587 \times 10^{3}$. Note-se que $x$ tem $5$ dígitos na mantissa. Por outro lado, os números $0.135\times 10^3$ e $0.136\times 10^3$ estão representados exatamente em ${\rm SPF}(10,3,-5,5)$]. Assim,
+
--
.. por truncamento: 
+
[latexmath]
++++
\[
nr_x=0.135\times 10^3;
\]
++++
.. por arredondamento:
+
[latexmath]
++++
\[
nr_x=0.136\times 10^3;
\]
++++
--

... Se latexmath:[$|x| < {\rm m}$,  por exemplo $x=0.123 \times 10^{-6}$. Este número não pode ser representado  em ${\rm SPF}(10,3,-5,5)$, devido a que o expoente $\exp=-6 \leq -5 = \exp_{\rm min}$]. Nesta  situação o sistema acusará *underflow*;
... Se latexmath:[$|x| > {\rm M}$,  por exemplo $x=0.456 \times 10^{7}$. Este número não pode ser representado em ${\rm SPF}(10,3,-5,5)$, devido a que o expoente $\exp=7 \geq 5 = \exp_{\max}$]. Nesta  situação o sistema acusará *overflow*. 


[NOTE]
Algumas linguagem de programação permitem que as variáveis possam ser declaradas com precisão dupla, e isto implica que a variável utilizará o dobro de dígitos disponíveis na mantissa, o que acarretará no aumento do tempo de execução e requerimentos de memória.


=== Erros

Nas medições cientificas, quando se aproxima um número real latexmath:[$x$ mediante outro número $\overline{x}$, o erro que resulta é $x-\overline{x}$], isto é:
[latexmath]
++++
\[
{\rm Erro}= x-\overline{x}.
\]
++++
Porém, dependendo da magnitude da quantidade que esta sendo medida, tal erro pode ser aceitável ou não. Por exemplo, se perguntamos a uma pessoa: Qual é a distância entre a Terra e a Lua? e esta responde: 384401 kms, seria algo assombroso, pois erro somente será de 1 km, porém este tipo de erro não seria aceitável no pousso de uma aeronave. Por este motivo precisamos estabelecer conceitos fundamentais para o bom entendimento desta teoria.

==== Erro Absoluto

Definição 1.1:: O *erro absoluto*, denotado por latexmath:[${\rm EA}_x$, é a diferença entre o valor exato de um número $x$ e de seu valor aproximado $\overline{x}$], isto é:
+
[latexmath]
++++
\[
{\rm EA}_x = x-\overline{x}.
\]
++++


Como na maioria das vezes o valor exato não está disponível, é necessário trabalhar com um limitante superior ou uma estimativa para o módulo do erro absoluto.

.{zwsp}
====
.. Dados  latexmath:[$\pi$ e  $\overline{\pi}$, com $\overline{\pi}$ sendo qualquer valor no intervalo aberto $(3.14, 3.15)$]. Temos que 
+
[latexmath]
++++
\[
|{\rm EA}_{\pi}|= | \pi - \overline{\pi}|< 0.01;
\]
++++
.. Dados latexmath:[$x$ e $\overline{x}$, com $\overline{x}= 332.9$] tal que:
+ 
[latexmath]
++++
\[
|{\rm EA}_x|< 0.1.\quad \mbox{Então} \quad x\in (332.8, 333);
\]
++++
.. Dados latexmath:[$y$ e $\overline{y}$, com $\overline{y}= 1.4$] tal que:
+ 
[latexmath]
++++
\[
|{\rm EA}_y|<0.1.\quad\mbox{Então}\quad y\in (1.3,1.5). 
\]
++++
====

Embora, os números latexmath:[$x$ e $y$] estão sendo representados com a mesma precisão, necessitamos saber a ordem de grandeza deles para obter uma maior precisão em nossos cálculos. Por este motivo,  precisamos conhecer o conceito de *erro relativo*.

==== Erro Relativo

Definição 1.2:: O *erro relativo*, denotado por  latexmath:[${\rm ER}_x$], é o erro absoluto dividido pelo seu valor aproximado, isto é:
+
[latexmath]
++++
\[
{\rm ER}_x = \frac{{\rm EA}_x}{\overline{x}} = \frac{x- \overline{x}}{\overline{x}}.
\]
++++

Podemos notar que o erro relativo proporciona mais informações sobre a qualidade do erro que estamos cometendo num determinado calculo, já que a ordem de grandeza do valor calculado é contemplada.

.{zwsp}
====
Do exemplo anterior, temos que:
[latexmath]
++++
\[
|{\rm ER}_x|= \frac{|{\rm EA}_x|}{|\overline{x}|}< \frac{0.1}{332.9} \approx 3.003\times 10^{-4}
\]
\[
|{\rm ER}_y|= \frac{|{\rm EA}_y|}{|\overline{y}|}< \frac{0.1}{1.4} \approx 0.071
\]
++++
Portanto, latexmath:[$x$ é representado com maior precisão que $y$].
====


//Em geral, nos procedimentos numéricos se gera uma sequencia de soluções aproximadas as quais no limite tendem ou não para a solução do problema.

==== Erros em um Sistema de Ponto Flutuante

A representação de um número em um sistema de ponto flutuante depende do computador usado, devido a que o seu sistema estabelecerá a base numérica adotada, o número de dígitos da mantissa, etc.

Sejam um número real latexmath:[$x$ e um equipamento que use o seguinte ${\rm SPF}(10,n, \exp_{\rm min}, \exp_{\rm max})$. Então $x$] pode ser reescrito como
[latexmath]
++++
\[
x=f_x\times 10^{\exp} + g_x\times 10^{\exp -n}
\]
++++
onde latexmath:[$0.1\leq f_x <1$ e $0\leq g_x <1$].  

[NOTE]
====
Nesta representação:
[latexmath]
++++
\[
nr_x=f_x\times 10^{\exp}
\]
++++
e latexmath:[$g_x\times 10^{\exp -n}$] é o valor que não pode ser incorporado totalmente à mantissa.
====

Por exemplo, consideremos latexmath:[$n=4$ e $x=123.45$], logo
[latexmath]
++++
\[
x=0.1234\times 10^{3} + 0.5\times 10^{-1}\qquad \mbox{e}\quad f_x=0.1234 \quad \mbox{e} \quad g_x= 0.5.  
\]
++++

Agora temos o problema de como considerar o valor de latexmath:[$g_x$] dentro mantissa, e estabelecer o erro absoluto (ou relativo) máximo cometido.


Como dito anteriormente, podemos adotar um dos seguintes critérios: 
[latexmath]
++++
\[
\mbox{truncar ou arredondar.}\]
++++


Quando consideramos o *truncamento*, o valor latexmath:[$g_x\times 10^{\exp -n}$] é desprezado, e o valor aproximado  é dado por:
[latexmath]
++++
\[
\overline{x}=f_x\times 10^{\exp}.
\]
Logo, $|g_x|<1$ implica que
\[
\begin{array}{rcl}
|{\rm EA}_x| &=& |x-\overline{x}| =  |g_x| \times 10^{\exp -n} < 10^{\exp -n}.
\end{array}
\]
Além disso, $1< \dfrac{1}{|f_x|} \leq \dfrac{1}{0.1}$ implica que
\[
\begin{array}{rcl}
|{\rm ER}_x| &=& \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{|g_x| \times 10^{\exp -n}}{|f_x| \times 10^{\exp} } < \dfrac{10^{\exp -n}}{0.1\times 10^{\exp}} = 10^{-n+1}.
\end{array}
\]
++++

Quando consideramos o *arredondamento*, latexmath:[$f_x$ é modificado para levar em conta o valor $g_x$]. A forma mais usada é o arredondamento simétrico:

[latexmath]
++++
\[
\overline{x} = \left\{
 \begin{array}{ccl} 
f_x\times 10^{\exp}, && \mbox{se}\quad |g_x|< \dfrac{1}{2};\\
&&\\
f_x\times 10^{\exp} + 10^{\exp-n}, && \mbox{se}\quad |g_x| \geq \dfrac{1}{2}.
\end{array}
\right.
\]
Em outras palavras, se $|g_x|< \dfrac{1}{2}$, então $g_x$ é desprezado, caso contrário somamos o número $1$ ao último digito de $f_x$. Logo, se $|g_x|<\frac{1}{2}$, então
\[
\begin{array}{l}
|{\rm EA}_x|= |x-\overline{x}| =|g_x|\times 10^{\exp-n} < \dfrac{1}{2}\times 10^{\exp-n}\\
\\
|{\rm ER}_x| = \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{|g_x| \times 10^{\exp -n}}{|f_x| \times 10^{\exp }} < 
\dfrac{0.5\times 10^{\exp -n}}{0.1\times 10^{\exp}} = \dfrac{1}{2} \times 10^{-n+1}
\end{array}
\]
se $|g_x|\geq\frac{1}{2}$, então
\[
\begin{array}{rcl}
|{\rm EA}_x|&=& |x-\overline{x}| \\
            &= & \left|(f_x\times 10^{\exp} + g_x\times 10^{\exp -n}) - (f_x\times 10^{\exp} +10^{\exp -n}) \right|\\                  
      &= &\left| g_x \times 10^{\exp-n} - 10^{\exp-n}\right| \\
&= & |g_x -1|\times 10^{\exp-n} \leq \frac{1}{2} \times 10^{\exp-n}\\
&&\\
|{\rm ER}_x| &=& \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{\frac{1}{2} \times 10^{\exp -n}}{|f_x \times 10^{\exp}+ 10^{\exp}|} \\
&<&  \dfrac{\frac{1}{2}\times 10^{\exp -n}}{|f_x|\times 10^{\exp}} < \dfrac{\frac{1}{2}\times 10^{\exp -n}}{0.1\times 10^{\exp}}<  \frac{1}{2} \times 10^{-n+1}
\end{array}
\]
Portanto, em ambos casos obtemos que os erros absolutos e relativos podem ser limitados pelas seguintes expressões:
\[
|{\rm EA}_x| \leq \frac{1}{2} \times 10^{\exp-n}\qquad\mbox{e}\qquad |{\rm ER}_x|< \frac{1}{2} \times  10^{-n+1}
\]
++++
Apesar da geração de erros menores no arredondamento, este demanda um tempo maior de execução, e por isto o truncamento é mais usado.

==== Propagação do erro



Quando efetuamos por exemplo latexmath:[$x=[(y+w)-z\]+v$] devemos ter em consideração como o erro em uma operação se propaga ao longo das próximas  operações. O erro total numa operação é composto pelo erro dos fatores e pelo erro no resultado da operação. 



.{zwsp}
====
Considere um sistema de ponto flutuante de 4 dígitos, na base 10, e precisão dupla.  Sejam latexmath:[$x=0.457\times 10^4$ e $y=0.9168\times 10^2$, calcular $x+y$ e $x\times y$].


.. latexmath:[$x+y$]: A soma em aritmética de ponto flutuante requer o alinhamento dos pontos decimais dos números. Assim, a mantissa do números de menor expoente deve ser deslocada para a direita. Tal deslocamento deve ser de um número de casas decimais igual à diferença entre os dois expoentes. Então 
+
[latexmath]
++++
\[
x=0.457\times 10^4\quad \mbox{ e } y=0.009168\times 10^4
\]
++++
+
Assim, o resultado exato da operação é
+
[latexmath]
++++
\[
x+y=(0.457+ 0.009168)\times 10^4=0.466168\times 10^4.
\]
++++
+
devido a que em nosso sistema latexmath:[$t=4$], o resultado deve de ser arredondado ou truncado. Assim
+
--
... no arredondamento: latexmath:[$\overline{x+y}= 0.4662\times 10^4$];
... no truncamento: latexmath:[$\overline{x+y}= 0.4661\times 10^4$].
--

.. latexmath:[$x\times y$]:
+
[latexmath]
++++
\[
x \times y =(0.457\times 10^4) \times(0.9168\times 10^2) = (0.457\times 0.9168)\times 10^6 = 0.4189776 \times 10^6
\]
++++
+
devido a que em nosso sistema latexmath:[$t=4$], o resultado deve de ser arredondado ou truncado. Assim
+
--
... no arredondamento: latexmath:[$\overline{x\times y}= 0.4190\times 10^6$];
... no truncamento: latexmath:[$\overline{x \times y}= 0.4189\times 10^6$].
--
====


O exemplo anterior mostra que ainda que as parcelas estejam representados de forma exata no sistema de ponto flutuante, não podemos esperar que o resultado seja exato.

Quando trabalhamos num processo numérico, o processamento dos dados envolve um número de operações elementares. Assim em uma operação o erro poderia não ser significativo para a solução do problema, porém a situação muda quando estão envolvidas um número muito grande de operações. Nesta situação, é importante saber como os erros estão se propagando, isto é, caso estejam se acumulando a uma taxa crescente, diremos que o erro é ilimitado, e a sequencia de operações é considerada *instável*.

Caso contrário, os erros estão se acumulando a uma taxa decrescente, dizemos que o erro é limitado, e a sequencia de operações é considerada *estável*.


image::images/cap1/Erro_lim_ilim.eps[scaledwidth="80%"]



.{zwsp}
====
Usando Aritmética de ponto flutuante de 4 dígitos, base decimal e arredondamento por truncamento, calcule o valor da seguinte soma:
[latexmath]
++++
\[
S= \sum\limits^{4}_{i=1}(x_i+y_i),\qquad \mbox{com}\quad x_i=0.46709\quad y_i=3.5678\quad \forall\,i=1,2,3,4. 
\]
++++
... Para latexmath:[$i=1$ $\Rightarrow$ $S_1=x_1 + y_1=0.46709 + 3.5678 = 0.4034 \times 10^1$]
+
[latexmath]
++++
\[
\mbox{Erro absoluto:} \quad {\rm EA}_{S_1}=4.03569 - 4.034= 0.00169= 0.169 \times 10^{-2}. 
\]
++++
... Para latexmath:[$i=2$ $\Rightarrow$ $S_2=(x_1 + y_1) + (x_2 +y_2)=0.4034 + 0.4034 = 0.8068 \times 10^1$]
+
[latexmath]
++++
\[
\mbox{Erro absoluto:} \quad {\rm EA}_{S_2}=8.07138 - 8.068= 0.00338= 0.338 \times 10^{-2}. 
\]
++++
... Para latexmath:[$i=3$ $\Rightarrow$ $S_3=(x_1 + y_1) + (x_2 +y_2) +  (x_3 +y_3) =0.4034 + 0.4034 + 0.4034 = 0.1210 \times 10^2$]
+
[latexmath]
++++
\[
\mbox{Erro absoluto:} \quad {\rm EA}_{S_3}=12.10707 - 12.10= 0.00707= 0.707 \times 10^{-2}. 
\]
++++
... Para latexmath:[$i=4$ $\Rightarrow$ $S_4=(x_1 + y_1) + (x_2 +y_2) +  (x_3 +y_3) + (x_4 + y_4) =+ 0.4034 + 0.4034 + 0.4034 + 0.4034 = 0.1613 \times 10^2$],
+
[latexmath]
++++
\[
\mbox{Erro absoluto:} \quad {\rm EA}_{S_4}=16.14276 - 16.13= 0.01276= 0.12767 \times 10^{-1}. 
\]
++++
====

Observamos que a medida que aumentam as operações de adição e considerando a aritmética de ponto flutuante definida, o erro absoluto esta crescendo. Assim a medida que latexmath:[$i$] seja muito grande a sequencia de operações pode torna-se instalável.

.{zwsp}
====
Considere a sequencia gerada por:
[latexmath]
++++
\[
x_{i+1}=\frac{1}{2} \left( x_i + \frac{2}{x_i} \right),\qquad \forall\, i=1,2,\ldots
\]
++++
Nesta sequencia, observamos que estão envolvidas as operações de adição, multiplicação e divisão, as quais são repetidas até que seja obtido o valor aproximado de latexmath:[$x_i$ o qual deve ser uma solução com uma precisão desejada $\epsilon$].

Assim, o valor final latexmath:[$x_i$] possui um determinado tipo de erro, a cada iteração o erro pode se propagar ao longo de todo o processo, o qual caso a sequencia tender para um número, apesar dos erros cometidos a cada passo, temos que a sequencia de operações torna-se estavel. 
====
////

=== Atividades
. Representar na base binária os seguintes números decimais:
\begin{enumerate}
\item 12
\item 35
\item 2341
\item 0.1234
\item 27.65
\item 0.6871
\end{enumerate}
\item Converta os seguintes números binários para sua forma decimal
\begin{enumerate}
\item $(101011)_2$
\item $(1111011)_2$
\item $(0.1101)_2$
\item $(0.1111111)_2$
\item $(101011)_2$
\end{enumerate}
\item Representar os seguintes números na forma normalizada
\begin{enumerate}
\item $(101)_{10}$
\item $(0.0123)_{10}$
\item $(1101)_2$
\item $(0.1111111)_2$
\item $(101011)_2$
\end{enumerate}
\item Represente na reta os positivos exatamente representáveis do sistema de ponto flutuante normalizado ${\rm SPF}(2,2,-1,2)$.
\item Considere um sistema de ponto flutuante normalizado ${\rm SPF}(2,4,-1,2)$. Calcule
\begin{enumerate}
\item o menor positivo exatamente representável;
\item o maior positivo exatamente representável; 
\item a quantidade exata de positivos representáveis;
\item o número total de reais exatamente representáveis
\end{enumerate}
\item No sistema de ponto flutuante normalizado ${\rm SPF}(10,3,-1,2)$, represente, em cada caso, o valor arredondado e o truncado dos  seguintes números:
\begin{enumerate}
\item $x=0.1234567$
\item $x=89123.1$
\item $x=23.4019$
\item $x=0.23101$
\item $x=543.21$
\end{enumerate}
Alem disso, calcule $|{\rm EA}_x|$ e $|{\rm ER}_x|$
\end{enumerate}

////



